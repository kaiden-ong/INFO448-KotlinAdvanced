/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package edu.uw.complexkotlin

// write a lambda using map and fold to solve "FIZZBUZZ" for the first fifteen numbers (0..15).
// use map() to return a list with "", "FIZZ" (for 3s) or "BUZZ" (for 5s).
// use fold() to compress the array of strings down into a single string.
// the final string should look like FIZZBUZZFIZZFIZZBUZZFIZZFIZZBUZZ for 0..15.
// store this lambda into 'fizzbuzz' so that the tests can call it
//
val fizzbuzz : (IntRange) -> String = { IntRange ->
    IntRange.map { num ->
        when {
            num % 3 == 0 && num % 5 == 0 -> "FIZZBUZZ"
            num % 3 == 0 -> "FIZZ"
            num % 5 == 0 -> "BUZZ"
            else -> ""
        }
    }.fold ("") { acc, str -> acc + str }
}

// Extra Credit #2 (DOH!)
// Here I'm writing the fizzbuzzdoh function, where if the number is evenly divisible by 7, then DOH! and only DOH! is returned.
// Ie. even if then number is divisible by 3 or 5, only DOH! is returned.
val fizzbuzzdoh : (IntRange) -> String = { IntRange ->
    IntRange.map { num ->
        when {
            num % 7 == 0 -> "DOH!"
            num % 3 == 0 && num % 5 == 0 -> "FIZZBUZZ"
            num % 3 == 0 -> "FIZZ"
            num % 5 == 0 -> "BUZZ"
            else -> ""
        }
    }.fold ("") { acc, str -> acc + str }
}

// Extra Credit #3 (fizzbuzzgen):
// Here I'm writing the fizzbuzzgen function, which returns a lambda which can solve fizzbuzz with any map with numbers mapped to Phrases
// View Test Cases in the test file
fun fizzbuzzgen(fizzbuzzMap: Map<Int, String>): (IntRange) -> String {
    return { numbers ->
        numbers.map { num ->
            fizzbuzzMap.map { (divisor, phrase) ->
                if (num % divisor == 0) {
                    phrase
                } else {
                    ""
                }
            }
        }.fold("") { acc, str -> acc + str.fold("") { accPhrase, phrase -> accPhrase + phrase}}
    }
}

// Example usage
// if (fizzbuzz(1..2) == "")
//     println("Success!")
// if (fizzbuzz(1..3) == "FIZZ")
//     println("Success!")
// if (fizzbuzz(1..5) == "FIZZBUZZ")
//     println("Success!")

// This is a utility function for your use as you choose, and as an
// example of an extension method
fun Int.times(block: () -> Unit): Unit {
    for (it in 1..this) {
        block()
    }
}

// Use this function
fun process(message: String, block: (String) -> String): String {
    return ">>> ${message}: {" + block(message) + "}"
}
// Create r1 as a lambda that calls process() with message "FOO" and a block that returns "BAR"
val r1 = { process("FOO") {"BAR"} }

// Create r2 as a lambda that calls process() with message "FOO" and a block that upper-cases 
// r2_message, and repeats it three times with no spaces: "WOOGAWOOGAWOOGA"
val r2_message = "wooga"
val r2 = { process("FOO") {r2_message.repeat(3).toUpperCase()}}

// write an enum-based state machine between talking and thinking
enum class Philosopher { 
    THINKING {
        override fun signal() = TALKING
        override fun toString() = "Deep thoughts...."
    },
    TALKING {
        override fun signal() = THINKING
        override fun toString() = "Allow me to suggest an idea..."
    };
    abstract fun signal(): Philosopher
}

/* Extra credit #4 & 5 (Seneca the Younger & Stoicism):
Seneca the Younger was a Stoic philosopher in Ancient Rome, born 4 AD and lived until 65 AD.
Stoicism is actually the school of philosophy that he is most commonly related with, which 
is the practice of virtue in order to achieve happiness and good life (AKA eudaimonia).
*/

// create an class "Command" that can be used as a function.
// To do this, provide an "invoke()" function that takes a 
// single parameter ("message" of type String). Command's
// primary constructor should take a String argument ("prompt").
// When invoked, the Command object should return a String
// containing the prompt and then the message.
// Example:
// val cmd = Command(": ")
// val result = cmd("Hello!")
// result should equal ": Hello!"
class Command(val prompt: String) { 
    operator fun invoke(message: String) : String {
        return "$prompt$message"
    }
}